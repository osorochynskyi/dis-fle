---
title: "Exploration donn√©es qualidays"
author: "Oleksandr Sorochynskyi"
date: "`r lubridate::today()`"
bibliography: biblio.bib
output:
    pdf_document: 
        number_sections: true
        keep_tex: no
        latex_engine: lualatex
        toc: true
        fig_crop: false # Causses error while looking for '/usr/bin/pdfcrop'
        includes:
            in_header: "papreambule.tex"
---

```{r setup, include = FALSE}
# Pretty much all settings are loaded except for knit options
source("R/options_visual.R")
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Le but de ce document est de structurer l'exploration des donn√©es "Qalidays".
Il s'agit d'une base de donn√©es de passages √† l'h√¥pital pour cause grave et
concerne l'ensemble de tels passages sur le territoire fran√ßais. De plus,
les donn√©es sont compl√©t√©es par des informations suppl√©mentaires sur la personne
concern√©e, tel que leur √¢ge approximatif, le sexe, r√©gion de d'habitation, etc.
Le dernier statut connu pour les personnes est √©galement indiqu√©, par exemple en
vie (censur√©) ou d√©c√®s.

Les finalit√©s des √©tudes pr√©c√©dentes sur ces donn√©es √©taient des estimations de
l'esp√©rance de vie en fonction de divers facteurs de risque ; l'estimation
de l'incidence des divers maladies graves et l'impact des facteurs de risque
sur cette incidence.

Ici, avant de s'attaquer √† d'autres probl√©matiques, je tenterai de re-produire
les r√©sultats des √©tudes pr√©c√©dentes et en ce faisant explorer les donn√©es. 

Plus pr√©cis√©ment, les buts sont les suivants :

1. Donner la distribution de dur√©e de vie, toutes causes confondue ;
1. Identifier des facteurs de risque avec influence sur la dur√©e de vie
attendu ;
1. Distinguer plusieurs causes de d√©c√®s ;
1. Identifier l'incidence d'autres √©tats que le d√©c√®s.


# Description donn√©es

## Contexte

La base de donn√©es √©tudi√©e est un extrait de PMSI qui ne contient que les
personnes ayant au moins un sejour h√¥pital pour un pathologie grave. La base
PMSI regroupe l'ensemble des passages √† l'h√¥pital en France, avec les
pathologies est soins appliqu√©s. Le periode d'observation des passages est
entre 2008 et 2013. Or, pour isoler un cohort des personnes en bonne sant√©,
les personnes avec des passages pour pathologies graves en 2008 et 2009 √©taient
exclus.

En plus de l'information sur les passages √† l'h√¥pital la base
inclut des informations sur l'individu, tel que leur √¢ge et des
facteurs de risque. Il faut noter que cette information sur l'individu donne
une vision statique, c'est-√†-dire que ces informations ne sont pas mises √† jour
√† chaque passage.

Les donn√©es, tels que transmis, sont sous la forme d'un tableau. Avec une
ligne par passage, puis avec les informations sp√©cifiques √† l'indivus √©tant
dupliqu√©es Comme je le montre par la suite j'ai trouv√© qu'il est plus facile
de s√©parer ce tableau en deux.

## Interval d'observation

Tous les passages en h√¥pital ont √©t√© enregistr√©s. Les ann√©es d'observation sont
2008,2009,2010,2011,2012,2013. Sur ces six ann√©es les patients avec passage
√† l'hopital pour motif grave en 2008 et 2009 ont √©t√© supprim√©s. Cela correspond
√† un sort de troncature √† gauche, il n'est pas clair comment integrer cela √† 
l'analyse.

Pour les individus observ√©s ils √©taient observ√©s, les √©v√©nements `STATE2_PDV`
et `STATE1_NO_PATHOL1` correspondent √† la censure et √† une visite sans aucune
des pathologies que l'on √©tudie. Ainsi, je consid√®re que touts les individus
sont observ√©s du 01-01-2008 au 31-12-2013, avec seulement `STATE2_PDV`,
`STATE2_DECES` √©tant des √©v√©nements censurant.

## Exploration

Pour faciliter l'exploration des donn√©s, un √©chantillon al√©atoire est utilis√©e.

```{r}
d <- tar_read(raw_benchmarks) %>%
    filter(id %in% c(75403, sample(id, size = 10e3)))
```

On peut d'abord constater que la majorit√© des colonnes sont des indicatrices
pour des diverses pathologies. Par exemple :

```{r}
sample(colnames(d)[22:111], size = 10)
```

On note qu'une de ces pathologies est `"STATE2_DECES"`.


### Dates de passage

D'abord j'interroge l'intervalle de temps. Je note que :

1. Les donn√©es couvent globalement 2008 √† 2013 ;
2. Il y a une incidence nettement plus basse en 2008 √† 2010 ;
3. Il y a une forte p√©riodicit√© avec des points d'accumulation.

```{r}
ggplot(d, aes(x = date_event)) +
    geom_histogram(binwidth = 5)
```

Le p√©riode d'observation est effectivement de 2008 √† 2013. La plus faible
incidence en 2008 et 2009 est expliqu√© par le fait les individus pour qui il y
a eu une survenance d'une pathologie grave dans ces deux ans √©taient
supprim√©s. L'id√©e est de garder uniquement les individus en bonne sant√© sur le
p√©riode de 2010 √† 2013. Ainsi dans la suite on est contraint de garder la m√™me
convention.

La suppression des individus avec des pathologies graves est refl√©t√© dans
l'absence de tout √©v√©nement non censurant avant 2010, comme le montre le
tableau ci-dessous.

```{R}
d %>%
    {
        full_join(
            filter(., year(date_event) < 2010) %>% pull(event) %>% fct_count(),
            filter(., year(date_event) >= 2010) %>% pull(event) %>% fct_count(),
            by = "f",
            suffix = c("_av2010", "_ap2010")
        )
    } %>%
    arrange(desc(n_av2010)) %>%
    head(20) %>%
    kable("latex")
```

Concernant la p√©riodicit√©, il apparait que la date "pic" tombe syst√©matiquement
sur le 16 ou le 15 de chaque mois.

```{r}
d %>%
    group_by(date_event) %>%
    count() %>%
    arrange(desc(n)) %>%
    head(10) %>%
    kable("latex")
```

De plus, la p√©riodicit√© est extr√™mement r√©guli√®re avec la distribution des jours
de passage √† l'int√©rieur du mois est tr√®s stable. Comme vu
pr√©c√©demment le pic tombe sur le 16 du mois, sauf pour le mois de f√©vrier.

```{r}
d %>%
    filter(year(date_event) >= 2008) %>%
    slice_sample(prop = 0.1) %>%
    mutate(
        dat_stat = format(floor_date(date_event, "month"), "%Y-%m"),
        dat_stat = factor(dat_stat, levels = sort(unique(dat_stat)))
    ) %>%
    ggplot() +
    aes(
        x = day(date_event),
        group = dat_stat,
        color = ifelse(month(date_event) == 2, "f√©v.", "autre")
    ) +
    geom_density() +
    labs(color = "")
```

Ce pattern est tr√®s r√©gulier --- je soup√ßonne que c'est le reflet de la m√©thode
de l'anonymisation.

### Age 

L'√¢ge des patients est partiellement bruit√©, on ne dispose que de l'√¢ge
arrondi. On peut quand m√™me en d√©duire la date de naissance approximative pour
le comparer √† la population globale.

```{r distribution_des_naissances}
d %>%
    mutate(
        bday = ymd("2008-01-01") - days(round(365.25 * age_20080101))
    ) %>%
    ggplot() +
    aes(x = bday) %>%
    geom_histogram(binwidth = 40)
```

```{r distribution_ages}
d %>%
    ggplot() +
    aes(x = age_20080101, fill = factor(male)) %>%
    geom_histogram(binwidth = 1) +
    facet_grid(rows = vars(male))
```

L'allure des ages parait normal", sauf le fait que les ages sont tronqu√©s
√† 44 ans (au 2008/01/01).

Comme le perim√®tre est d√©fini sur la population de 50 et plus. Alors il n'est
pas clair comment c'est reflait√© dans la base, car les ages de survenance
sont parfaois inf√©reurs √† 50 (eviron 5% de la population).

```{r}
d %>%
    group_by(id) %>%
    summarize(
        max_age = max(age_event),
        min_age = min(age_event),
        .groups = "drop"
    ) %>%
    filter(max_age < 50) %>%
    mutate(err = 50 - max_age) %>%
    ggplot() +
    aes(x = err) +
    geom_histogram(binwidth = 0.1)
```

Je soup√ßonne qu'il s'agit, √† nouveau, d'un artifact li√© √† la m√©thode de censure.
Il serait peut-√™tre interessant, voire n√©cessaire d'int√©grer cet source d'al√©a
dans la mod√©lisation. Ici ce qui est interssant c'est que l'on peut identifier
la distribution du bruit appliqu√©.


### Sexe

La majorit√© de la base sont des femmes, ce qui est peu √©tonnant vu qu'il s'agit
d'une population dont les √¢ges faibles sont tronqu√©s.

```{r}
d$male %>%
    as.character() %>%
    fct_count(prop = TRUE) %>%
    mutate(n = scales::number(n), p = scales::percent(p)) %>%
    rename(male = f) %>%
    kable("latex")
```

### Facteurs de risque

```{r}
d %>%
    select(starts_with("fdr_")) %>%
    summary()
```

Trois facteurs de risque sont identifi√©es :

* La consommation d'alcool (`"aud"`) ;
* la consommation de tabac (`"smoker"`) ;
* l'ob√©sit√© (`"obesity"`) ;

Pour chaque facteur de risque deux niveaux de granularit√© sont identifi√©s :

* tout niveau de gravit√© confondus (`"all"`) ;
* trois niveau de gravit√© : aucun, faible et sev√®re (`"cat3"`).

Par exemple :

```{R}
d %$%
    table(fdr_aud_all, fdr_aud_cat3)
```

### Autres variables

```{r}
d %>%
    select("cp_dep", "cp_immi", "cp_dipl0", "prob_hosp0813", "cp_reg") %>%
    mutate(
        across(starts_with("cp"), factor),
        across(starts_with("prob"), ~ as.numeric(as.character(.)))
    ) %>%
    summary()
```

La variable `cp_dep` correspond au d√©partement de l'individu.

La variable `cp_immi` correspond au statut d'immigration de l'individu (la
signification de chaque code est inconnu).

`cp_dipl0` correspond au niveau d'√©tudes (`dipl` pour dipl√¥me).

Il faut noter que cette information est constat√© √† l'individu fix√©. Elle est
notamment constante dans le temps. Le tableau ci-dessous v√©rifie que
les colonnes cit√©es sont bien constantes √©tant donn√© un `id`.

```{r}
d %>%
    filter(id %in% sample(id, 10e3)) %>%
    filter(
        duplicated(id, fromLast = TRUE) | duplicated(id, fromLast = FALSE)
    ) %>%
    group_by(id) %>%
    summarize(
        across(
            c(age_20080101, male, starts_with("fdr"), starts_with("cp")),
            n_distinct
        ),
        .groups = "drop"
    ) %>%
    summarize(
        across(-id, ~ all(. == 1L))
    ) %>%
    kable("latex") %>%
    kable_styling(latex_options = "scale_down")
```

### `prob_hosp0813` 

Cette variable a √©t√© construit pour pouvoir ajuster l'analyse pour prendre en
compte que la base ne contient que la population hospitalis√©e et donc ajuster
l'exposition.

J'imagine le calcul comme √ßa : si parmi toutes les entr√©es en h√¥pital
10 % sont avec une maladie X et de plus  5 % de la population qui
rentre en h√¥pital (l'info de la colonne `prob_hosp0813`),
la proba de rencontrer cette maladie dans la population g√©n√©rale est
de 5 % * 10 %, soit 0.5 %.

Dans tous les cas Quentin sugg√®re que cette variable n'a pas √©t√© retenu et que
l'on fera mieux de l'ignorer.

### `anee_event` et `age_event`

Informations recalculables √† partir de la date de l'√©v√©nement.

### `t_last`, `time1`, `time2`, `status`

Variables calcul√©es pour faciliter l'analyse de survie. Nous les recalculerons
lorsqu'en aura besoin.

### Pathologies

Ici on s'int√©resse √† l'√©v√©nement qui a provoqu√© le passage √† l'h√¥pital. D'abord
je note que la majorit√© des √©v√©nements correspond au `"STATE2_PDV"` et
`"STATE1_NO_PATHOL1"`, qui correspond aux situations o√π l'individu n'a pas de
passage √† l'h√¥pital pour un motif grave. En effet, ces deux √©v√©nements
repr√©sentant √† peu pr√®s 60 % des √©v√©nements (ces chiffres sont biais√©s par les
√©v√©nements avant 2010).

```{r}
fct_count(d$event, sort = TRUE, prop = TRUE) %>%
    mutate(n = number(n), p = percent(p, .1)) %>%
    head(15) %>%
    kable("latex")
```

Je note que lorsque les deux motifs sont pr√©sents `"STATE2_PDV"` est forc√©ment
pr√©c√©d√© par `"STATE1_NO_PATHOL1"`". 

```{r}
d %>%
    select(id, event, date_event) %>%
    group_by(id) %>%
    mutate(n_autres = sum(event %in% c("STATE2_PDV", "STATE1_NO_PATHOL1"))) %>%
    ungroup() %>%
    filter(n_autres > 1) %>%
    arrange(id, date_event) %>%
    pivot_wider(id_cols = id, names_from = event, values_from = date_event) %>%
    mutate(diff = interval(STATE1_NO_PATHOL1, STATE2_PDV) / days(1)) %>%
    summarize(prop_pos = mean(diff > 0)) %>%
    kable("latex")
```

Pour comprendre mieux la structure prenons quelques exemples concrets.

```{R}
d %>%
    select(id, event, date_event) %>%
    group_by(id) %>%
    mutate(
        nb_evenements = n(),
        nb_autres = sum(event %in% c("STATE2_PDV", "STATE1_NO_PATHOL1"))
    ) %>%
    ungroup() %>%
    filter(nb_evenements > 1) %>%
    group_by(nb_autres) %>%
    filter(id %in% sample(unique(id), size = 1)) %>%
    arrange(id, date_event) %>%
    kable("latex")
```

On distingue ainsi trois situations :

1. lorsqu'il y a qu'un seul √©v√©nement qui apparait l'√©v√©nement "STATE2_PDV"
correspond √† l'admission de censure ;
1. lorsque aucun de ces deux √©v√©nements n'apparait le dernier √©v√©nement est
un d√©c√®s ;
1. lorsque ces deux √©v√©nements apparaissent il s'agit d'un parcours censur√© sans
pathologie constat√©.

Environ 80 variables indiquent la pr√©sence de diverses pathologies dans
l'histoire du patient. D'abord il faut noter que ces pathologies sont
des regroupements des autres pathologies bien plus fines. (cf. travaux de
Micha√´l sur ce groupement)

La valeur de ces colonnes correspond √† l'age auquel cette pathologie a √©t√©
d√©tect√© ou `0` lorsque la pathologie n'a jamais √©tait d√©tect√© chez cet
l'individu. Par exemple, le tableau ci-dessous donne un cas concret d'un
individu avec plusieurs visites √† l'h√¥pital.

```{r}
d %>%
    filter(id %in% c(75403)) %>%
    select(
        id, date_event, event, age_event,
        CARDIO1_RYTHME_1ACFA, CANCER1_PC_GOOD, BLOOD1_1TRANSFUSION,
        KIDNEY1_1INSUF_CHRO, STATE2_DECES
    ) %>%
    kable("latex") %>%
    kable_styling(latex_options = "scale_down")
```

De plus comme on a l'√¢ge de l'occurrence de la pathologie on peut calculer
le taux d'incidence ainsi que l'√¢ge moyen d'incidence. 

```{r}
d %>%
    arrange(date_event) %>%
    filter(!duplicated(id)) %>%
    summarize(
        across(
            BLOOD0_2ANEMIA_IRON:STATE2_DECES,
            list(taux = ~ mean(. != 0), moyen = ~ mean(.[. > 0]))
        ),
        .groups = "drop"
    ) %>%
    pivot_longer(
        everything(),
        names_to = c("pathologie", "type"),
        names_pattern = "(.*)_(taux|moyen)$"
    ) %>%
    pivot_wider(
        id_cols = c("pathologie"),
        values_from = value,
        names_from = type
    ) %>%
    filter(taux > 0, !is.nan(moyen)) %>%
    mutate(across(taux, percent), across(moyen, number_format(0.1))) %>%
    arrange(desc(taux)) %>%
    rename(`Taux d'incidence` = taux, `Age moyen` = moyen) %>%
    head(20) %>%
    kable("latex")
```

Les pathologies sont classif√©es en 3 groupes : 0, 1, 2. 2 c'est essentiellement
la mort. 1 c'est une pathologie grave, qui est d'ailleur consittue le crit√®e
d'inclusion dans la base de donn√©es : ce sont des individus avec au moins un
passage pour une pathologie 1, cf les travaux de Micha√´l pour plus de d√©tail
sur la d√©finition de cette classe. 0 ce sont des pathologies relativement
peu graves (relativement au pathol1 et 2). Il faut noter que malgr√© la pr√©sence
des pathol0 dans les colonnes avec les pathologies, nous n'avons pas de
l'information dessus : toutes ces colonnes sont syst√©matiquement nulles.

### `age_pathol1`

Cette variable semble correspondre au premier √¢ge d'entr√©e en h√¥pital et est
donc recalculable √† partir des autres colonnes.

### `file`

Variable ajout√© par moi-m√™me, correspond au fichier de source de la ligne.
Il apparait que certaines informations dont l'emplacement g√©ographique sont
encod√©s dans le nom du fichier. Or, l'information g√©ographique est d√©j√†
disponible dans la variable `cp_dep`, donc cette variable sera probablement
inutilis√©.

# Autres sources de donn√©es

Jusqu'ici nous nous sommes interss√©s aux donn√©es issus de la concatenation
des benchmarks de Quentin. Il existe cependant une autre version des donn√©es
sous la forme de CSV qui sert d'input pour la g√©n√©ration de benchmarks.
Les donn√©es sous cette forme sont beaucoup plus proches du format retenu
in fine et n√©cessite donc moins de retraitements. Il apparait √©galement qu'il y
a plus d'information dans ces fichiers-l√†. Par exemple lorsque plusieurs
pathologies surviennent le m√™me jour qu'une seule est retenu dans les
benchmarks, alors que dans les .csv elles sont toutes pr√©sentes.

Il existe deux variantes de donn√©es en `.csv` avec et sans imputation.
Sans imputation ce sont les donn√©s tels que vu dans les benchmarks. Avec
imputation, les donn√©es sont censur√©s au 2012-12-31, ce qui est bien mieux que
juste supprimer les donn√©s.

Pour ne retenir un source de donn√©es unique, je choisi de sourcer le `.csv`
sans imputation, puis y appliquer toutes les retraitements.

La proc√©dure de censure est la suivante. Tous les √©v√©nements au-dela du 
2012-12-31 sont remplac√©s par un "STATE2_PDV". Lorsqu'il n'y a pas eu d'autres
√©v√©nments avant 2012-12-31, je ratouge un √©v√©nement "STATE1_NO_PATHOL1" √†
cette date.

Cettre proc√©dure diff√®re de celle appliqu√© par Micha√´l. D'abord, lorsqu'il y a
eu qu'un seul √©v√©nment, et cet √©v√©nement est un "STATE1_NO_PATHOL1" en 2013, il
est gard√© tel qu'il est. Lorsque tous les √©v√©nements observ√©s sont dans 2013,
il semblerait qu'un √©v√©nement "STATE1_NO_PATHOL1" est rajout√©. Je sup√ßonne que
le d√©ail sur les "STATE1_NO_PATHOL" est supprim√© lorsqu'il y a eu des PATHOL1.
Enfin, il semble que dans certains cas, lorsque touts les √©v√©nements surviennent
en 2023, le premier √©v√©nement est convertie en "STATE1_NO_PATHOL1". Cela
n'impacte rien, car il semble que de toute fa√ßon les personnes sans √©v√©nements
avant 2013 sont exclues.

La proc√©dure que j'applique consiste √† rajouter des STATE1_NO_PATHOL1 maquants,
puis appliquer la proc√©dure de censure.

Il a √©t√© d√©cid√© de retenir comme source le fichier CSV, car celui-ci contient
le plus d'information. Il apparait que lorsque'il y a eu plusieurs √©v√©nments
le m√™me jour, le benchmark n'en retient qu'un. Y compris si un des √©v√©nement 
est un d√©c√®s. J'ai cru que `event_censor` d√©t√©rmine la priorit√© des √©v√©nment
mais, il existe des cas o√π d√©c√®s a un `event_censor` nul, ou m√™me o√π
le d√©c√®s a un `event_censor` √† 2 mais qu'il ne soit pas retenu. En tout
je conste qu'il y a des √©v√©nements de moins dans les benchmarks, y compris des
d√©c√®s. En tout il y a 5 millions d'√©v√©nements en plus.


# Normalisation

La structure de la base parait avoir √©t√© retrait√© pour un certaine analyse.  A
mon sens la base de donn√©es serait plus facile √† manipuler si elle serait
d√©compos√©e en deux tables :

1. La table des individus avec l'information associ√©s ;
2. La table des √©v√©nements.

Voire une troisi√®me table pour les pathologies si on aura suffisamment
d'info (je pense notamment si on ne peut pas grouper les pathologies).

De plus, la base contient des variables qui sont recalculables √† partir des
autres informations. Ainsi, en plus de d√©composer la base en deux tables, je
vais supprimer les colonnes calcul√©es.

En plus de la matrice avec les ages de survenues, les variables suivants
risquent d'√™tre calcul√©s :

* `date0_pathol1` `age_pathol1`
* `annee_event`, `age_event`
* `pathol1_classif`
* `t_last`, `time1`, `time2`

Apr√®s retraitements la base des individus rassemble √† :

```{r}
tar_read(individu) %>%
    slice_sample(n = 10) %>%
    kable("latex") %>%
    kable_styling(latex_options = "scale_down")
```

Et la base des √©v√©nements :

```{r}
tar_read(evenement) %>%
    filter(id %in% sample(id, size = 5)) %>%
    kable("latex")
```

De plus, on sohaite conserver la posibilit√© d'appliquer ou pas l'imputation
des d√©c√®s. Pour cela deux versions des bases `individu` et `evenement` sont 
cr√©√©s, une avec application des imputation et une sans. Le volume des donn√©es
avec imputation est plus faible car toutes les personnes avec une date
d'hospitalisation en 2013 sont exclues. Le raisonement pour ce choix n'est pas
clair pour moi, mais je le r√©produit pour s'alignier avec les travaux
pr√©c√©dents. Une explication possible serait le fait que le m√©thode d'imputation
sur-estime le nombre de d√©c√®s pour les hospitalisations en 2013.

## Matrice age √©v√©nements 

Tout d'abord nous supprimons l'ensemble des colonnes avec les noms de
pathologies, car elles sont recalculables √† partir des dates de passages √†
l'h√¥pital. Il faut noter qu'il y a bien plus de pathologies dans les colonnes
que dans les √©v√©nements. Or, les colonnes correspondants √† des pathologies qui
n'ont aucun √©v√©nement sont syst√©matiquement nulles.

```{r}
mat_even <- d %>%
    select(BLOOD0_2ANEMIA_IRON:STATE2_DECES)

not_in_event <- !colnames(mat_even) %in% levels(d$event)
colnames(mat_even)[not_in_event]

mat_even[, not_in_event] %>% sum()
```

Inversement, les deux √©v√©nements qui n'ont pas de colonne correspondante sont

```{r}
levels(d$event)[!levels(d$event) %in% colnames(mat_even)]
```


## `date0_pathol1` `age_pathol1`

Concernant les variables √¢ge et date de la premi√®re pathologie, il apparait
qu'ils ont recalcul√©s comme suit :

```{r}
p1 <- d %>%
    filter(
        id %in% sample(id, 1e3),
        !event %in% c(
            "STATE2_DECES", "STATE2_PDV", "STATE1_NO_PATHOL1",
            "STATE1_DEP_PHYSIQUE"
        )
    ) %>%
    mutate(
        bday = ymd("2008-01-01") - days(round(365.25 * age_20080101)),
        age_pathol = interval(bday, date_event) / years(1)
    ) %>%
    group_by(id) %>%
    summarize(
        date0_pathol1 = min(date_event),
        age_pathol1 = age_pathol[which.min(date_event)],
        .groups = "drop"
    )

d %>%
    select(event, date_event, date0_pathol1, age_pathol1, id) %>%
    mutate(across(date0_pathol1, ~ mdy(as.character(.)))) %>%
    right_join(p1, by = "id", suffix = c("", "_new")) %>%
    filter(date0_pathol1 != date0_pathol1_new) %>%
    nrow()
```

Or lorsqu'on compare les ages √† la premi√®re pathologie, ils diff√®rent
r√©guli√®rement, g√©n√©ralement d'un jour environ.

```{r}
d %>%
    select(event, date_event, date0_pathol1, age_pathol1, id) %>%
    mutate(across(date0_pathol1, ~ mdy(as.character(.)))) %>%
    right_join(p1, by = "id", suffix = c("", "_new")) %>%
    mutate(err_age = (age_pathol1 - age_pathol1_new) * 365.25) %>%
    filter(abs(err_age) > 1) %>%
    head(20) %>%
    kable("latex")
```

Je me pose la question de si ces ages-l√† n'√©taient pas calcul√©s d'une autre
mani√®re. Je compare ainsi toutes les sources de l'√¢ge disponibles :

* la colonne `age_20080101` ;
* la colonne `age_pathol1` ;
* les colonnes avec les pathologies ;
* la colonne `age_event`.

Pour faire la comparaison, je r√©unis ces sources en une seule table.

```{r}
x <- d %>%
    filter(id %in% sample(id, 10e3))

age1 <- x %>%
    transmute(id = id, date_event = ymd("20080101"), age = age_20080101) %>%
    unique()

age2 <- x %>%
    filter(!is.na(date0_pathol1)) %>%
    filter(!duplicated(id)) %>%
    transmute(
        id = id,
        date_event = mdy(as.character(date0_pathol1)),
        age = age_pathol1
    ) %>%
    unique()

age3 <- x %>%
    select(id, event, date_event, BLOOD0_2ANEMIA_IRON:STATE2_DECES) %>%
    pivot_longer(
        cols = BLOOD0_2ANEMIA_IRON:STATE2_DECES,
        values_to = "age",
        names_to = "event2"
    ) %>%
    filter(event == event2) %>%
    select(id, date_event, age) %>%
    unique()

age4 <- x %>%
    select(id, date_event, age = age_event) %>%
    unique()

ages <- bind_rows(
    age_20080101 = age1,
    age_pathol1 = age2,
    pathol_mat = age3,
    age_event = age4,
    .id = "source"
) %>%
    arrange(id) %>%
    mutate(bday = date_event - days(round(age * 365.25)))

xx <- ages %>%
    group_by(id) %>%
    summarize(is_const = sd(bday) == 0, .groups = "drop")

ages %>%
    filter(id %in% sample(xx$id[!xx$is_const], 2)) %>%
    kable("latex")
```

Je constate que dans la majorit√© des cas toutes les sources conduisent √† la m√™me
date de naissance. Les exceptions sont peu nombreuses. La majorit√© des
exceptions pr√©sentent un jour d'√©cart, en plus ce jour-l√† tombe le 31 d√©cembre.
L'autre source de l‚Äô√©cart est l'`age_pathol1` qui lui aussi peut conduire √† des
dates de naissance diff√©rentes.

Comparons `age_20080101` et `age_pathol1` 

```{r}
ages %>%
    filter(source %in% c("age_20080101", "age_pathol1")) %>%
    pivot_wider(
        id_cols = id,
        names_from = source,
        values_from = bday
    ) %>%
    filter(age_20080101 != age_pathol1) %>%
    kable("latex")
```

Enfin de compte des √©carts sont assez rares, et surtout, dans la majorit√© des
cas `age_pathol1` survient plus tard, ce qui me conduit √† conclure qu'il n'est
pas calcul√© sur le m√™me √©v√©nement. 

## `annee_event`, `age_event`

Le calcul de l'ann√©e et √¢ge de l'√©v√©nement parait trivial, or j'identifie
des √©carts ! Ces √©carts concernent ~30 lignes (sur ~400k) donc je les consid√®re
que ce sont des cas aberrants. (le nombre exact des √©carts d√©pend de
l'√©chantillon choisi).

```{r}
d %>%
    filter(id %in% sample(id, 10e3)) %>%
    transmute(
        date_event = date_event,
        age_event = age_event,
        anee_event = annee_event,
        annee_event2 = year(date_event),
        bday = ymd("2008-01-01") - days(round(365.25 * age_20080101)),
        age_event2 = interval(bday, date_event) / years(1),
        err_anee = annee_event2 - as.numeric(annee_event),
        err_age = age_event2 - age_event
    ) %>%
    filter(err_anee != 0 | abs(err_age) > 1) %>%
    nrow()
```


## `t_last`, `time1`, `time2`

```{r}
d %>%
    filter(id %in% sample(id, 10e3)) %>%
    mutate(
        bday = ymd("2008-01-01") - days(round(365.25 * age_20080101))
    ) %>%
    group_by(id) %>%
    summarize(
        bday = head(bday, 1),
        # time1 = ymd("2008-01-01"),
        time2 = max(date_event),
        .groups = "drop"
    ) %>%
    mutate(
        time1 = interval(bday, ymd("2008-01-01")) / years(1),
        time2 = interval(bday, time2) / years(1)
    ) -> x

d %>%
    select(id, event, date_event, time1, time2, t_last) %>%
    inner_join(x, by = "id", suffix = c("", "_new")) %>%
    head(10) %>%
    kable("latex") %>%
    kable_styling(latex_options = "scale_down")
```

##  `event_censor`

La variable `event_censor` indique si l'√©v√©nement est √† consid√®rer comme une
censor. Elle permet nottamant d'identifier les d√©c√®s imput√©s. Les d√©c√®s observ√©s
et imput√©s sont tous les deux indiqu√©es par `event == "STATE2_DECES"`, alors que
les d√©c√®s observ√©s correspondent uniquement aux cas o√π
`event == "STATE2_DECES" & event_censor == 0`. Pour conserver les deux visions,
avec imputation et sans, l'on distangue deux bases `evenement` avec et sans
imputations. Pour la version avec imputation il suffit d'ignorer la colonne
`event_censor` et consid√®rer tout "STATE2_DECES" comme un vrai d√©c√®s. Pour la
version sans imputation, l'on remplace "STATE2_DECES" par "STATE2_PDV", pour
les cas o√π `event_censor != 0`.

Il est √† noter qu'il semble que cette variable peut varier que pour
"STATE2_DECES", "STATE2_PDV" et "CV1_PVD". L'interpretation est connue que pour
la variable "STATE2_DECES". Pour "STATE2_PDV" il semblerait que `event_censor == 1`
correspond √† une vrai censure, alors que `event_censor == 2` correspond √† une
censure "artificiel" au 2012/12/31. Le cas
`event_censor == 2 & event == "STATE2_PDV"` n'arrive que dans la base "imput√©",
c'est √† dire, la base censur√© au 2012/12/31.

The following code snipped is from `R/create_base_incidence.R` and
defines the whether or not death is taken into account.

```{R, eval = FALSE, include = TRUE}
# Mise a jour de 09/11/2017 pour gestion des type deces
obs_deces <- as.numeric(base[, "event_censor"])
if (type_deces == "type_0") {
    # selection des deces observes a l hopital
    cond_type_dc <- (obs_deces == 0)
} else if (type_deces == "type_1") {
    # selection des deces observes a l hopital ou patients graves imputes
    cond_type_dc <- ((obs_deces == 0) | (obs_deces == 1))
} else if (type_deces == "type_2") {
    cond_type_dc <- ((obs_deces == 0) | (obs_deces == 1) | (obs_deces == 2))
} else if (type_deces == "type_3") { # 21/06/2018 QG Cas supplementaire pour gerer le deces de type 3
    obs_deces <- as.numeric(base[, "event_censor_sp95"])
    cond_type_dc <- ((obs_deces == 0) | (obs_deces == 1) | (obs_deces == 3))
} else {
    stop("Erreur de definition de la variable type_deces")
}
```

Which seems to state the following :

* `type_0` ~ `event_censor == 0`
* `type_1` ~ `event_censor %in% c(0, 1)`
* `type_2` ~ `event_censor %in% c(0, 1, 2)`.
* `type_3` ~ `event_censor_sp95 %in% c(0, 1, 3)`

As stated a bit further down, Quentin suggests that `type_3` is not kept,
but it is not clear whether `type` 1 or 2 should be used for imputations.
Just jugging from volumes `type_1` will not add enough imputations since
there are very few lines with `event_censor == 1`.

En conclusion, pour les d√©c√®s observ√©s ne garder que `event_censor == 0`
et pour les d√©c√®s imput√©s garder `event_censor %in% c(0, 1, 2)`.
    
Une autre evenement o√π `event_censor` peut avoir un impact c'est "CV1_PVD".
Actuellement `event_censor` est ignor√© vis-√†-vis de cette variable.


# Parcours donn√©es projet Quentin

Dans cette section je d√©taille les retraitements que j'ai retrouv√©s dans le
code source du projet pr√©c√©dent. Cette section sera surtout utile pour des
√©changes avec Quentin, les autres peuvent la sauter.

J'ai pu √©tablir l'ordre d'ex√©cution suivant dans les fichiers :

1. `scripts/0-init_analysis_fixe.R`
1. `param/config_estim_nejm.R`
1. `scripts/1.1-run_cox_incidence_qalydays.R`
1. `R/run_save_cox_serie1.R`
1. `R/clean_benchmark.R`
1. `R/create_base_incidence.R`
1. `R/cox_comp_risk.R`

Le script "run_cox_incidence_qalydays" source les deux premiers fichiers, qui
contient essentiellement de la configuration, puis ex√©cut√© la fonction
"run_save_cox_serie1", qui a son tour appelle "clean_benchmark",
"create_base_incidence" et "cox_comp_risk" avant de sauvegarder le r√©sultat.

Un des param√®tres les plus importants, c'est le `type_deces` qui peut prendre
les valeurs "type_0", "type_1", "type_2" et "type_3". "type_0" consiste √† ne pas
imputer les d√©c√®s. Les autres types consistent √† consid√©rer que certaines
pathologies vont quasi-certainement conduit √† un d√©c√®s et donc remplacent ces
causes de sortie par un d√©c√®s (imputent le d√©c√®s pour le formuler autrement).
La configuration conseill√©e par Quentin (√† savoir "config_1") prend "type_0".
Quentin m'a indiqu√© que **"type_3" n'est pas retenu**, il n'est pas clair qu'en
est-il du "type_2".

## `clean_benchmark`

Cette √©tape applique quelques retraitements.

1. attache la probabilit√© d'hospitalisation (via une jointure) =>
**√©tape saut√©**
1. fait un ajustement de la variable "fdr_smoker" => **√©tape appliqu√©e**
1. applique la une "correction fumeur" => **√©tape saut√©e**
1. applique une correction des poids => **√©tape saut√©e**
1. met √† jour la r√©gion => **√©tape appliqu√©e**
1. applique ajustement d√©c√®s ("type_2") => **√©tape saut√©e**
1. ajuste les dates de `STATE1_DEM_SEVERE` => **√©tape appliqu√©e**
1. filtrage de ligne en fonction du `date0_hopital` => **√©tape appliqu√©e**

## `create_base_incidence`

Cette fonction pr√©pare les donn√©es pour une analyse de type Cox. Plus
pr√©cis√©ment elle met les donn√©es sous la forme o√π il ne contient plus que les
colonnes : "id", "time1", "time2", "status", "cause" et les covariables
utilis√©es pour l'analyse √† savoir "fdr_aud_cat3", "fdr_smoker",
"fdr_obesity_cat3", "cp_dep".

Des nombreuses r√®gles sont appliqu√©es pour d√©cider lorsqu'un individu est
consid√©r√©e comme √©tant censur√©, et pour d√©finir l'intervalle d'observation.

En tout, touts les retraitements d√©finis ici **sont saut√©s**, car ils servent √†
d√©finir les temps d'entr√©e, de sortie et le statut de sortie, ce que l'on peut
red√©finir si besoin.

1. ajuste la d√©finition de la colonne `STATE2_DECES` en utilisant `event_sp95`,
si le type d√©c√®s retenu, c‚Äôest "type_3"
1. (re)d√©finit `age_pathol1` en excluant les issus en d√©c√®s et d√©pendance
1. d√©finit `age_pathol1_cum2`/`age_pathol1_cum3` en excluant la
premi√®re/deuxi√®me pathologie et d√©c√®s et d√©pendance (que lorsque l'issu √©tudi√©e
est `age_pathol1_cum2`/`age_pathol1_cum3`)
1. d√©finit encore de beaucoup variables qui ne semblent pas √™tre
utilis√©es
1. arrondit/tronque des valeurs num√©riques 
1. d√©finit de temps d'entr√©e de sortie et le statut de sortie (ü§Ø)

## `run_save_cox_serie1`

En plus des fonctions cit√©es ci-dessous des petits retraitements sont appliqu√©s
dans `run_save_cox_serie1`, que l'on liste ici.

1. Initie deux grosses boucles :

    - une sur l'ensemble des segments (les donn√©s sont divis√©es en segments de
    d√©partement-sexe)
    - l'autre sur les pathologies √©tudi√©es

1. appelle `clean_benchmark` => **√©tape appliqu√©e**
1. ajoute la colonne `pathol1_classif`  => **√©tape saut√©e**
1. ajoute les colonnes `event_censor` et `event_censor_sp95`, via jointure avec
"ID_IMPUT0812_SPE95" => **√©tape saut√©e**
1. appelle `create_base_incidence` => **√©tape saut√©e**
1. applique le mod√®le de cox via un appel √† `cox_comp_risk` => **√©tape saut√©e**

